## netty启动服务流程
### 创建nioeventloopgroup

#### nioeventloop的创建及Selector创建
NioEventLoopGroup的构造方法中会通过SelectorProvider生成selector,每个平台的SelectorProvider不同:

1. java.nio.channels.spi.SelectorProvider系统属性配置了,会直接使用
2. 用classLoader去load已经安装的jar包里的可见的在META-INF/services  目录下java.nio.channels.spi.SelectorProvider的实现类
3. 否则选择该系统下默认 SelectorProvider的实现类

以下为代码

	public NioEventLoopGroup(int nThreads, Executor executor) {
        this(nThreads, executor, SelectorProvider.provider());
    }

    public static SelectorProvider provider() {
        synchronized (lock) {
            if (provider != null)
                return provider;
            return AccessController.doPrivileged(
                new PrivilegedAction<SelectorProvider>() {
                    public SelectorProvider run() {
                            if (loadProviderFromProperty())
                                return provider;
                            if (loadProviderAsService())
                                return provider;
                            provider = sun.nio.ch.DefaultSelectorProvider.create();
                            return provider;
                        }
                    });
        }
    }
	在windows下的实现类为:sun.nio.ch.WindowsSelectorProvider

再来看其具体过程:
![NioEventLoopGroup实例化](pic/-1.jpg)	

NioEventLoopGroup的实例化构造方法会传递到父类MultithreadEventExecutorGroup的实例化如上图.
首先进来创建线程池,executor第一次肯定为null,创建县城工厂定义想成prefix为nioEventLoopGroup-2-.
![executor](pic/-1.1.jpg)
可以看到他的run方法就是开个新线程然后直接start,这个线程池用来启动nio线程

接下来创建nio线程容器:children = new EventExecutor[nThreads];
然后再循环中: children[i] = newChild(executor, args); 来创建每个NioEventLoop

![newChild](pic/-1.2.jpg)
在newChild中去创建NioEventLoop

    NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,
                 SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler,
                 EventLoopTaskQueueFactory taskQueueFactory, EventLoopTaskQueueFactory tailTaskQueueFactory) {
        super(parent, executor, false, newTaskQueue(taskQueueFactory), newTaskQueue(tailTaskQueueFactory),
                rejectedExecutionHandler);
        this.provider = ObjectUtil.checkNotNull(selectorProvider, "selectorProvider");
        this.selectStrategy = ObjectUtil.checkNotNull(strategy, "selectStrategy");
        final SelectorTuple selectorTuple = openSelector();
        this.selector = selectorTuple.selector;
        this.unwrappedSelector = selectorTuple.unwrappedSelector;
    }

在openSelector()中unwrappedSelector = provider.openSelector();
用provider来创建未包装的selector,在windows下是sun.nio.ch.WindowsSelectorImpl

最后一部根据child的数量实例化:chooser = chooserFactory.newChooser(children);
![chooser](pic/-1.3.jpg)
chooser是一个NioEventLoopGroup的其中NioEventLoop的选择器,其作用见下面.ServerSocketChannel的注册流程.

### ServerBootstrap的bind流程
ServerBootStarp绑定
代码如下:

   	private ChannelFuture doBind(final SocketAddress localAddress) {
		//初始化并注册channel
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        if (regFuture.cause() != null) {
            return regFuture;
        }

        if (regFuture.isDone()) {
            // At this point we know that the registration was complete and successful.
            ChannelPromise promise = channel.newPromise();
			//如果上面完成了初始化和注册,直接在主线程doBind0
            doBind0(regFuture, channel, localAddress, promise);
            return promise;
        } else {
            // Registration future is almost always fulfilled already, but just in case it's not.
            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
			//等待register完成再来bind
            regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                        // IllegalStateException once we try to access the EventLoop of the Channel.
                        promise.setFailure(cause);
                    } else {
                        // Registration was successful, so set the correct executor to use.
                        // See https://github.com/netty/netty/issues/2586
                        promise.registered();

                        doBind0(regFuture, channel, localAddress, promise);
                    }
                }
            });
            return promise;
        }
    }


initAndRegister()为异步实例化ServerSocketChannel,并且绑定到selector的逻辑;

regFuture.isDone()为完成时,直接在主线程里调用 doBind0(),否则把他封装成listerer来等待register完成后调用listerer;


#### channel实例化
AbstractBootstrap#initAndRegister()

此处用reflect实例化channel,传入的为NioServerSocketChannel或NioSocketChannel

    final ChannelFuture initAndRegister() {
        Channel channel = null;
        try {
            channel = channelFactory.newChannel();
            init(channel);
        } 
		...
		ChannelFuture regFuture = config().group().register(channel);

再来看init(channel);

##### ServerSocketChannel初始化

    @Override
    void init(Channel channel) {
        setChannelOptions(channel, newOptionsArray(), logger);
        setAttributes(channel, newAttributesArray());

        ChannelPipeline p = channel.pipeline();

        final EventLoopGroup currentChildGroup = childGroup;
        final ChannelHandler currentChildHandler = childHandler;
        final Entry<ChannelOption<?>, Object>[] currentChildOptions = newOptionsArray(childOptions);
        final Entry<AttributeKey<?>, Object>[] currentChildAttrs = newAttributesArray(childAttrs);

        p.addLast(new ChannelInitializer<Channel>() {
            @Override
            public void initChannel(final Channel ch) {
                final ChannelPipeline pipeline = ch.pipeline();
                ChannelHandler handler = config.handler();
                if (handler != null) {
                    pipeline.addLast(handler);
                }

                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        pipeline.addLast(new ServerBootstrapAcceptor( 
                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });
    }

设置了channel和childChannel的参数.这里的childChannel是socketChannel,channel为ServerSocketChannel.

不过childChannel是之后该channel通过ServerBootstrapAcceptor创建的,所以childChannel的参数由ServerBootstrapAcceptor接收处理.

在最后,在channel的流水线中加入ChannelInitializer,他的作用是在channel的pipeline中加入ServerBootstrapAcceptor,这个ServerBootstrapAcceptor的作用是建立连接用的,即创建SocketChannel,具体逻辑在他的channelRead方法中.

注意这里的把ServerBootstrapAcceptor加入pipeline的操作由nio线程完成.这里目前不会执行.因为ChannelInitializer本质上是ChannelInboundHandlerAdapter,他的initChannel方法在后面channel的regist0流程中,由nio线程调用pipeline.fireChannelRegistered();再来触发!!

##### SocketChannel初始化
比较简单,把handler设置进去,设置选项和参数即返回!

    @Override
    void init(Channel channel) {
        ChannelPipeline p = channel.pipeline();
        p.addLast(config.handler());

        setChannelOptions(channel, newOptionsArray(), logger);
        setAttributes(channel, newAttributesArray());
    }

#### 把channel注册到bossgroup的NioEventLoop中的selector上
见 AbstractBootstrap#initAndRegister()的

ChannelFuture regFuture = config().group().register(channel);

config().group()拿的就是bossgroup,见下图:
![0](pic/0.jpg)
![1](pic/1.jpg)

MultithreadEventLoopGroup#register()
	
	@Override
    public ChannelFuture register(Channel channel) {
        return next().register(channel);
    }

next()方法返回一个EventLoop,在其中有个choser选择EventLoopGroup中的一个EventLoop,有轮训和2的幂次方2种选择器,EventExecutor的实现类为EventLoop
![2](pic/2.jpg)

再来看EventExecutor#register(channel),跳转到SingleThreadEventLoop#register(Channel channel),最后实现为AbstractChannel#register(EventLoop eventLoop, ChannelPromise promise)

如果当前线程是eventLoop线程,那就直接执行register0,否则用eventLoop线程执行!,这里目前是用户线程,走下面分支,会异步调用channel的AbstractChannel.AbstractUnsafe#register0(promise);

       @Override
        public final void register(EventLoop eventLoop, final ChannelPromise promise) {
           ...省略参数校验

            AbstractChannel.this.eventLoop = eventLoop;

            if (eventLoop.inEventLoop()) {
                register0(promise);
            } else {    
                 eventLoop.execute(new Runnable() {
                     @Override
                     public void run() {
                         register0(promise);
                     }
                    });
            } 

我们先看eventLoop#execute(Runnable)方法,这就是n打包放入队列的逻辑:

	private void execute(Runnable task, boolean immediate) {
        boolean inEventLoop = inEventLoop();
        addTask(task);
        if (!inEventLoop) {
            startThread();
        }

        if (!addTaskWakesUp && immediate) {
            wakeup(inEventLoop);
        }
    }
将任务包装后放入nioeventLoop的queue中,

这里是线程切换的老套路,

如果nio线程没启动就调用startThread()方法,

否则直接返回,nio线程在启动的情况下会自动执行队列中的task!!

在这里将会判断nio线程的状态,没有启动的话,这里开始更新状态,启动nio线程

    private void startThread() {
        if (state == ST_NOT_STARTED) {
            if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) {
                boolean success = false;
                try {
                    doStartThread();
                    success = true;
                } finally {
                    if (!success) {
                        STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);
                    }
                }
            }
        }
    }

在doStartThread();中会使用NioEventLoopGroup中创建的executor来启动一个新线程

    private void doStartThread() {
        assert thread == null;
        executor.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    SingleThreadEventExecutor.this.run();
                    success = true;
                } catch (Throwable t) {
                    logger.warn("Unexpected exception from an event executor: ", t);
                } finally {
                    //释放资源
				}
            }
        });
    }

我们再来看SingleThreadEventExecutor.this.run();,这个模板方法调用NioEventLoop的run方法,开始了无尽for循环的select过程,其中会执行我们放在queue的task;

再来看打包成task的register0方法,他会在eventloop线程中调用

		private void register0(ChannelPromise promise) {
                boolean firstRegistration = neverRegistered;
                doRegister();
                neverRegistered = false;
                registered = true;

                // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the
                // user may already fire events through the pipeline in the ChannelFutureListener.
                pipeline.invokeHandlerAddedIfNeeded();

                safeSetSuccess(promise);
                pipeline.fireChannelRegistered();
                // Only fire a channelActive if the channel has never been registered. This prevents firing
                // multiple channel actives if the channel is deregistered and re-registered.
                if (isActive()) {
                    if (firstRegistration) {
                        pipeline.fireChannelActive();
                    } else if (config().isAutoRead()) {
                        // This channel was registered before and autoRead() is set. This means we need to begin read
                        // again so that we process inbound data.
                        //
                        // See https://github.com/netty/netty/issues/4805
                        beginRead();
                    }
                } 
        }

在AbstractNioChannel#doRegister()中,将jdkchannel注册到selector上,这里传入的select参数为0,表示不select任何操作,因为这里还没bind,这个this传进去为了select到事件后,可以方便调用channel(的pipeline)来处理

    @Override
    protected void doRegister() throws Exception {
        boolean selected = false;
        for (;;) {
          
          selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
          return;
        }
    }

接下来调用register0中的safeSetSuccess(promise);他会调用上面的AbstractBootStrap#doBind0(regFuture, channel, localAddress, promise);

调用链见下图：
![safeSetSuccess调用doBind0](pic/3.jpg)

### 回到Bootstrap的bind流程,开始

	channel.eventLoop().execute(new Runnable() {
            @Override
            public void run() {
                if (regFuture.isSuccess()) {
                    channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
                } else {
                    promise.setFailure(regFuture.cause());
                }
            }
        });

这里调用nio线程的execute操作,将bind操作打包成task,直接返回到register0方法!所以真正的bind操作是一个异步的过程

接下来看异步的AbstractChannel#bind中

    @Override
    public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {
        return pipeline.bind(localAddress, promise);
    }

通过pipeline的HeadContext的bind最终调用NioServerSocketChannel#doBind

    protected void doBind(SocketAddress localAddress) throws Exception {
        if (PlatformDependent.javaVersion() >= 7) {
            javaChannel().bind(localAddress, config.getBacklog());
        } else {
            javaChannel().socket().bind(localAddress, config.getBacklog());
        }
    }

AbstractChannel#AbstractUnsafe#bind中

		if (!wasActive && isActive()) {
                invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        pipeline.fireChannelActive();
                    }
                });
            }

看到这里判断进fireChannelActive的条件有2个

前一个为true,后一个isActive为模板方法,实现类在serverSocketChannel:

	@Override
    public boolean isActive() {
        // As java.nio.ServerSocketChannel.isBound() will continue to return true even after the channel was closed
        // we will also need to check if it is open.
        return isOpen() && javaChannel().socket().isBound();
    }

我们看到在serverSocketChannel中只有绑定成功才会返回true,只有在绑定成功后才会触发pipeline.fireChannelActive(),这里会进这个逻辑;

他会联级触发HeadContext的channelActive,里面会注册读事件readIfIsAutoRead();
见AbstractNioChannel#doBeginRead()

	if ((interestOps & readInterestOp) == 0) {
            selectionKey.interestOps(interestOps | readInterestOp);
    }
这里在selector上注册OP_ACCEPT了,绑定流程全部完成


##### 回到AbstractChannel#AbstractUnsafe#register0

接下来在bossnio线程中调用fireChannelRegistered,在pipeline中传播registered时间,这会联机触发ChannelInitializer#fireChannelRegistered方法.,他会将ServerBootstrapAcceptor注册到bossnio线程的pipeline中,用于初始化socketchannel;

接下来AbstractChannel#AbstractUnsafe#register0中调用isActive()来看是否要pipeline.fireChannelActive();但是这里我们只是异步将bind操作封装为task,并没有执行,所以这里不会进fireChannelActive逻辑,本次eventloop完成!!将会在下一个loop中完成
需要注意的是,以上的nio线程都是BOSS Thread